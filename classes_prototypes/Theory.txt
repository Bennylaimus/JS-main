// ================== 1st Lesson: Intro into prototypes =========================================== // 

Prototypes are the mechanism by which JavaScript objects inherit features from one another.
JavaScript often described as a prototype-based-language - to provide inheritance objects can have a
prototype object, which acts as a template object that it inherits methods and properties from.

Example:

const arr = [1,2,3];
const arr2 = [4,5,6];

arr.includes(2) // true
arr2.includes(5) // true

Both arr and arr2 have 'built in' includes() method, which is stored in __proto__ property which is a reference to 'prototype',
which stores all array / string methods

Same have a DOM - for example:

const doc = document.body
console.dir(doc) // we will see some properties, that are specific to this exact body and a property __proto__ (HTMLBodyElement)

*************************
Array.prototype // shows all the prototypes Array have
String.prototype // shows all the prototypes String have

We can even define our own object prototype and set it as an Array prototype (and it will be available for all other arrays we will use)

String.prototype.grumpus = () => {
    alert('Go Away, you Grampus!') 
}

We have now added a grumpus() method to a String prototypes and this method will be seen by all other Strings

Another example:

String.prototype.grumpus = () => {
    alert('Go Away you nasty Grumpus!');
}

const cat = 'Blue';
cat.grumpus() // alert (Go Away ...)

Another example:

String.prototype.yell = function () {
    console.log(this);
}

this - refers to 'anything', that is one the left (after.), in our case to String (String.yell) => (String.this)
'hello'.yell (same as String.yell, 'hello'.this)
console.log(this.toUpperCase) ===> 'hello'.toUpperCase()

String.prototype.yell = function() => {
    return OMG! `${this.toUpperCase()}` !!! OMGIIIII!
}

'I Love Piccas'.yell() // 'OMG! I LOVE PICCAS !!! OMGIIIII!'

************************************************************

We can even override some of the properties, for example override array.pop property:

Array.prototype.pop = function () {
    return 'I will never ever pop it up!' // will are now replacing the existing .pop method
}

const arr3 = [7, 8, 9];

console.log(arr3.pop()); // output ==> 'I will never ever pop it up!'

// ================== 2nd Lesson: Intro Into OOP & Factory Function ==================================== // 

An OOP basically is a Object - Oriented - Programming: basically, there is one central idea:
"Organizing our code, designing and structuring our application by breaking things up by a distinct patterns of objects, 
giving them defined behavior, like recepies"

We will create our own class (a 'recepie') with color name 'carrot' and rgb value for it (230, 126, 34)
and we will be able to easiealy switch between different color systems (hsl, rgb, hex) and even choose
opposite color to one we have

Basically our navColor will have some added methods, like rgb(), rgba(), opposite()

****Example of FACTORY FUNCTION:***

Some ready-function taken from stackoverflow, that accepts x3 rgb value and converts them to a hex:
function hex(r, g, b) {
     return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}
hex(255, 100, 25); // ==> #ff6432;

1. We can write a function, that takes 3 colors (r, g and b) and convert it to a rgb(r, g, b)
something, that we already did before
function rgb(r, g, b) {
         return `rgb(${r}, ${g}, ${b})`;
}
rgb(200, 50, 100);

2. So we have two our functions hex() and rgb(), which are functioning by their own perfectly, but now
   we will try to add them to an object and switch rgb and hex value, without passing numbers to hex() and
   separatety to rgb() each time
   Basically, the function, that will create as such object is calling a factory function

  - this function will create an object, which will store:
 1. and 'r', 'g', 'b' as an object values
 2. will have hex() method inside of this object
 3. will have rgb() method inside of this object

function makeColor(r, g, b) {       // 1. We are creating a fucntion()
    const color = {}                // 2. inside a fucntion we are creating an empty object {}  
    color.r = r                     // 3. we are adding 'r' from the function argument to object (with standart syntax: color.r = r)
    color.g = g                     // 4. Same with 'g'
    color.b = b                     // 5. Same with 'b'
    At this point: makeColor(255, 100, 20) ===>
    ===> {r: 255, g: 100, b: 20}; - we have an object with this keys / values

    Now we can add an rgb() method inside our object:
    color.rgb = function rgb() {    // 6.adding an rgb() method to our object
        const { r, g, b } = this;   // 7.because we need to access to some values of an object inside a method, we are using 'this' keyword (this in our case in 'color' object) - we can use 'destruction method' and assign this.r, this.g, this.b that way (check destruction objects lesson) it is same as return `rgb(${this.r}, ${this.g}, ${this.b})`;
        return `rgb(${r}, ${g}, ${b})`;
    }
    Now we are also adding hex() method inside our object
    color.hex = function hex() {
        const { r, g, b } = this;  // or you can 'hard-code' it this.r, this.g, this.b
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    return color                   // 8. and in the end we want to return this object {} (color)
};

Now we need to create a variable and store our makeColor() in that variable
We need to do it, because we will need to call .rgb and .hex methods on this variable
We can't just to it directly in makeColor()

const myColor = makeColor(100, 200, 250);

console.log(myColor); // ====>
====> myColor in this case is an object, that contains keys r: g: b: and .rgb() method and hex() method
and we pass 100 to r, 200 to b and 250 to g at the moment we assiging myColor to = maleColor(100, 200, 250)

console.log(myColor.rgb()); // it's looks the same as makeColor().rgb()
It's like we would wrire maleColor(100, 200, 250).rgb() and call an .rgb method on it
console.log(myColor.hex());


